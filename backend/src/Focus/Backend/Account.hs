{-# LANGUAGE OverloadedStrings, GADTs, ScopedTypeVariables, QuasiQuotes, TemplateHaskell, FlexibleInstances, TypeFamilies, FlexibleContexts, NoMonomorphismRestriction #-}
{-# OPTIONS_GHC -fno-warn-orphans -Wno-unused-matches #-}
{- NOTE: We add a -Wno-unused-matches because the code generated by groundhog has an unused variable
  GROUNDHOG ERROR -
  src/Focus/Backend/Account.hs:35:1: warning: [-Wunused-matches]
    Defined but not used: ‘p’
  <no location info>: error:
  Failing due to -Werror.
-}
module Focus.Backend.Account where

import Focus.Backend.DB
import Focus.Backend.Email
import Focus.Backend.Schema.TH
import Focus.Backend.Sign
import Focus.Backend.Listen
import Focus.Backend.Mustache

import Focus.Account
import Focus.Brand
import Focus.Sign
import Focus.Route
import Focus.Schema

import Control.Monad.Trans.Except
import Control.Monad.Writer
import Crypto.PasswordStore
import Data.Aeson
import Data.ByteString (ByteString)
import Data.Default
import Data.Maybe
import Data.String
import Data.Text (Text)
import Data.Text.Encoding
import Data.Time
import Data.Typeable
import Database.Groundhog hiding ((~>))
import Database.Groundhog.Core hiding ((~>))
import Database.Groundhog.TH
import Database.Groundhog.Generic.Sql.Functions
import qualified Data.Text as T
import Text.Blaze.Html5 (Html)
import qualified Text.Blaze.Html5 as H
import Text.Blaze.Html5.Attributes as A
import Data.List.NonEmpty

import qualified Web.ClientSession as CS

mkPersist defaultCodegenConfig [groundhog|
  - entity: Account
    constructors:
      - name: Account
        uniques:
          - name: emailUnique
            type: index
            fields: [{expr: "lower(account_email::text)"}]
|]

makeDefaultKeyIdInt64 ''Account 'AccountKey

tokenToAuth :: (Typeable f, FromJSON (f (Id Account))) => CS.Key -> Signed (AuthToken f) -> Maybe (f (Id Account))
tokenToAuth csk = fmap unAuthToken . readSignedWithKey csk

migrateAccount :: PersistBackend m => TableAnalysis m -> Migration m
migrateAccount tableInfo = migrate tableInfo (undefined :: Account)

-- Returns whether a new account had to be created
ensureAccountExists :: (PersistBackend m, SqlDb (PhantomDb m)) => Email -> m (Bool, Id Account)
ensureAccountExists email = do
  nonce <- getTime
  mPrevId <- fmap (listToMaybe . fmap toId) $ project AutoKeyField (lower Account_emailField ==. T.toLower email)
  case mPrevId of
    Just prevId -> return (False, prevId)
    Nothing -> do
      result <- insertByAll $ Account email Nothing (Just nonce)
      case result of
        -- TODO: Better way to handle errors?
        Left _ -> error "ensureAccountExists: Creating account failed"
        Right aid -> do
          let aid' = toId aid
          notifyEntityId NotificationType_Insert aid'
          return (True, aid')

-- Creates account if it doesn't already exist and sends pw email
ensureAccountExistsEmail
  :: (PersistBackend m, MonadSign m, SqlDb (PhantomDb m), Typeable f, ToJSON (f (Id Account)))
  => (Id Account -> f (Id Account))
  -> (Signed (PasswordResetToken f) -> Email -> m ()) -- pw reset email
  -> Email
  -> m (Bool, Id Account)
ensureAccountExistsEmail = ensureAccountExistsEmail' ensureAccountExists

-- Creates account if it doesn't already exist and sends pw email
-- Allows the option for a custom "ensure account" creation function
ensureAccountExistsEmail'
  :: (PersistBackend m, MonadSign m, Typeable f, ToJSON (f (Id Account)))
  => (Email -> m (Bool, Id Account))
  -> (Id Account -> f (Id Account))
  -> (Signed (PasswordResetToken f) -> Email -> m ()) -- pw reset email
  -> Email
  -> m (Bool, Id Account)
ensureAccountExistsEmail' ensureAccount decorateAccountId pwEmail email = do
  ret@(_, aid) <- ensureAccount email
  mNonce <- generateAndSendPasswordResetEmail decorateAccountId pwEmail aid
  forM_ mNonce $ \nonce -> do
    update [Account_passwordResetNonceField =. Just nonce] (Account_emailField ==. email)
  return ret

generatePasswordResetToken :: ( PersistBackend m
                              , MonadSign m
                              , Typeable f
                              , ToJSON (f (Id Account))
                              )
                           => f (Id Account)
                           -> m (Signed (PasswordResetToken f))
generatePasswordResetToken aid = do
  nonce <- getTime
  sign $ PasswordResetToken (aid, nonce)

generatePasswordResetTokenFromNonce :: ( MonadSign m
                                       , Typeable f
                                       , ToJSON (f (Id Account))
                                       )
                                    => f (Id Account) 
                                    -> UTCTime 
                                    -> m (Signed (PasswordResetToken f))
generatePasswordResetTokenFromNonce aid nonce = sign $ PasswordResetToken (aid, nonce)

setAccountPassword :: (PersistBackend m, MonadIO m) => Id Account -> Text -> m ()
setAccountPassword aid password = do
  pw <- makePasswordHash password
  update [ Account_passwordHashField =. Just pw
         , Account_passwordResetNonceField =. (Nothing :: Maybe UTCTime) ]
         (AutoKeyField ==. fromId aid)

makePasswordHash :: MonadIO m => Text -> m ByteString
makePasswordHash pw = do
  salt <- liftIO genSaltIO
  return $ makePasswordSaltWith pbkdf2 (2^) (encodeUtf8 pw) salt 14

resetPassword :: (MonadIO m, PersistBackend m) 
              => Id Account
              -> UTCTime
              -> Text
              -> m (Maybe (Id Account))
resetPassword aid nonce password = do
  Just a <- get $ fromId aid
  if account_passwordResetNonce a == Just nonce
    then do
      setAccountPassword aid password
      return $ Just aid
    else return Nothing

login :: (PersistBackend m, SqlDb (PhantomDb m))
      => (Id Account -> m loginInfo) 
      -> Email 
      -> Text 
      -> m (Either LoginError loginInfo)
login toLoginInfo email password = runExceptT $ do
  (aid, a) <- ExceptT . fmap (maybeToEither LoginError_UserNotFound . listToMaybe) $ project (AutoKeyField, AccountConstructor) (lower Account_emailField ==. T.toLower email)
  ph <- ExceptT . return $ maybeToEither LoginError_UserNotFound $ account_passwordHash a
  when (not $ verifyPasswordWith pbkdf2 (2^) (encodeUtf8 password) ph) $ ExceptT $ return $ Left LoginError_InvalidPassword
  lift $ toLoginInfo (toId aid)
  where
    maybeToEither b Nothing = Left b
    maybeToEither _ (Just a) = Right a

loginByAccountId :: (PersistBackend m)
                 => Id Account
                 -> Text
                 -> m (Either LoginError ())
loginByAccountId aid password = runExceptT $ do
  a <- ExceptT . fmap (maybeToEither LoginError_UserNotFound . listToMaybe) $ project AccountConstructor (AutoKeyField ==. fromId aid)
  ph <- ExceptT . return $ maybeToEither LoginError_UserNotFound $ account_passwordHash a
  when (not $ verifyPasswordWith pbkdf2 (2^) (encodeUtf8 password) ph) $ ExceptT $ return $ Left LoginError_InvalidPassword
  return ()
  where
    maybeToEither b Nothing = Left b
    maybeToEither _ (Just a) = Right a

generateAndSendPasswordResetEmail
  :: (PersistBackend m, MonadSign m, Typeable f, ToJSON (f (Id Account)))
  => (Id Account -> f (Id Account))
  -> (Signed (PasswordResetToken f) -> Email -> m ())
  -> Id Account
  -> m (Maybe UTCTime)
generateAndSendPasswordResetEmail decorateAccountId pwEmail aid = do
  nonce <- getTime
  prt <- sign $ PasswordResetToken (decorateAccountId aid, nonce)
  ma <- get (fromId aid)
  forM ma $ \a -> do
    pwEmail prt (account_email a)
    return nonce

newAccountEmail :: (MonadBrand m, MonadRoute r m, Default r) 
                => (AccountRoute f -> r) 
                -> Signed (PasswordResetToken f) 
                -> m Html
newAccountEmail f token = do
  passwordResetLink <- routeToUrl $ f $ AccountRoute_PasswordReset token
  b <- getBrand
  emailTemplate Nothing
                (H.text $ "Welcome to " <> _brand_productName b)
                (H.a H.! A.href (fromString $ show passwordResetLink) $ H.text "Click here to verify your email")
                (H.p $ H.text $ _brand_description b)

sendNewAccountEmail :: (MonadRoute r m, Default r, MonadBrand m, MonadEmail m)
                    => (AccountRoute f -> r) -- How to turn AccountRoute into a route for a specific app
                    -> Signed (PasswordResetToken f)
                    -> Email
                    -> m ()
sendNewAccountEmail f prt email = do
  pn <- liftM T.pack getProductName
  body <- newAccountEmail f prt
  sendEmailDefault (email :| []) (pn <> " Verification Email") body

sendPasswordResetEmail :: (MonadBrand m, MonadEmail m, MonadRoute r m, Default r)
                       => (AccountRoute f -> r)
                       -> Signed (PasswordResetToken f)
                       -> Email
                       -> m ()
sendPasswordResetEmail f prt email = do
  passwordResetLink <- routeToUrl $ f $ AccountRoute_PasswordReset prt
  pn <- getProductName
  let lead = "You have received this message because you requested that your " <> pn <> " password be reset. Click the link below to create a new password."
      body = H.a H.! A.href (fromString $ show passwordResetLink) $ "Reset Password"
  sendEmailDefault (email :| []) (T.pack pn <> " Password Reset") =<< emailTemplate Nothing (H.text (T.pack pn <> " Password Reset")) (H.toHtml lead) body

sendPasswordResetMustacheEmail :: (MonadBrand m, MonadEmail m, MonadRoute r m, MonadMustache m)
                               => (AccountRoute f -> r) 
                               -> Text 
                               -> Text 
                               -> Text 
                               -> Text 
                               -> Signed (PasswordResetToken f) 
                               -> Email 
                               -> m ()
sendPasswordResetMustacheEmail f baseUrl unsubscribeUrl needHelpUrl privacyPolicyUrl prt email = do
  passwordResetLink <- routeToUrl $ f $ AccountRoute_PasswordReset prt
  let resetPasswordUrl = T.pack $ show passwordResetLink
  pn <- getProductName
  let emailTitle = ("Password Reset" :: Text)
  Just compiledTemplate <- compileMustache "reset-password.html"
  let emailBody = H.preEscapedToHtml $ substituteValue compiledTemplate $ mustacheObject
              [ "subject" ~> emailTitle
              , "baseUrl" ~> baseUrl
              , "resetPasswordUrl" ~> resetPasswordUrl
              , "unsubscribeUrl" ~> unsubscribeUrl
              , "needHelpUrl" ~> needHelpUrl
              , "privacyPolicyUrl" ~> privacyPolicyUrl
              ]
  sendEmailDefault (email :| []) emailTitle emailBody
